## A*寻路算法： 
求解最短路径 

## Dijkstra：最短路径算法 
>Dijkstra是荷兰的计算机科学家,提出”信号量和PV原语“,"解决哲学家就餐问题",”死锁“也是它提出来的

## DP (Dynamic Programming)   
动态规划：
动态规划法所针对的问题有一个显著的特征，即它所对应的子问题树中的子问题呈现大量的重复。动态规划法的关键就在于，对于重复出现的子问题，只在第一次遇到时加以求解，并把答案保存起来，让以后再遇到时直接引用，不必重新求解
经典案例：
1.丢硬币：

2.背包：
一个最优解的子解，也是最优解。

3.最大子数组和问题：

4.三角形问题
https://github.com/chengmo03013106/Learn-Algorithms/blob/master/15%E4%B8%AA%E7%BB%8F%E5%85%B8%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/DP%20%E7%AE%97%E6%B3%95

##BFS/DFS （广度/深度优先遍历）    


## 红黑树 

一种自平衡的`二叉查找树`
map和hash_map性能测试
大家都知道在C++的STL中map是使用树来做查找算法，而hash_map使用hash表来排列配对，是使用关键字来计算表位置。那使用起来他们的差别主要是什么呢？对于性能差别是什么，适合什么情况下应用呢？于是我对它们进行了一些测试，并记录了测试数据供大家分享。
    测试的内容主要是map和hash_map的添加、删除、查找和遍历操作，首先进行了几组测试，分别是10万次、30万次，时间单位均为毫秒，具体的性能对照如下：
    hash_map（10万） map（10万） hash_map（20万） map（20万） hash_map（30万） map（30万）
    添加    93             47            156             94           203           172
    遍历    16             15            16              16           16            15
    查找    0               0             32              31          31            32
    删除   8422            32           33765             63        76016           78


hash_map的添加和删除操作比map要慢，尤其是删除操作hash_map比map可能慢1000倍，从而得到结论是删除和插入操作较多的情况下，map比hash_map的性能更好，添加和删除的数据量越大越明显。


时间单位仍为毫秒：map遍历性能较好，查找性能低于hash map
    hash_map（100万） map（100万） hash_map（200万） map（200万） hash_map（300万） map（300万）
    遍历     94               31          203               32             297            47
    查找     94               234         188               531             281           875

### 结论：
两大组测试完毕，整体结论也可以得出：一般应用情况下，我们保存的数据不超过100万份，查找的频繁程度不高情况下使用map性能比较好；而保存的数据较多时（超过100万），查找频繁时使用hash_map的性能就高于map了。


##KMP    字符串匹配算法   

##遗传算法  

##启发式搜索   

##图像特征提取之SIFT算法  


##傅立叶变换  


##Hash  


##快速排序  


##SPFA(shortest path faster algorithm)  
单元最短路径算法  


##快递选择SELECT  

